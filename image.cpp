#include "image.hpp"
#include <fstream>
#include <sstream>
#include <stdexcept>
#include <cmath>
#include <algorithm>

Image::Image(size_t rows, size_t cols) : rows(rows), cols(cols), pixels(rows *cols, 0) {}

// Methods of obtaining dimensions
size_t Image::getRows() const { return rows; }
size_t Image::getCols() const { return cols; }

// Pixel access method
int &Image::at(size_t i, size_t j)
{
	if (i >= rows || j >= cols)
		throw std::out_of_range("Index out of bounds");
	return pixels[i * cols + j];
}

const int &Image::at(size_t i, size_t j) const
{
	if (i >= rows || j >= cols)
		throw std::out_of_range("Index out of bounds");
	return pixels[i * cols + j];
}

std::vector<int> Image::getPixels()
{
	return std::vector<int>(pixels);
}

// Reading an image from a file in PGMA format
bool Image::loadFromPGM(const std::string &filePath)
{
	std::ifstream file(filePath);
	if (!file.is_open())
		return false;
	
	std::string line, format;
	std::getline(file, format);
	format.erase(format.find_last_not_of(" \t\r\n") + 1);
	if (format != "P2")
		return false;

	while (std::getline(file, line))
	{
		if (line[0] != '#')
			break;
	}

	std::istringstream dimensions(line);
	dimensions >> cols >> rows;

	int maxVal;
	file >> maxVal;

	pixels.resize(rows * cols);
	for (size_t i = 0; i < rows * cols; ++i)
	{
		if (!(file >> pixels[i]))
			return false;
	}

	return true;
}

// Write an image to a file in PGMA format
void Image::saveToPGM(const std::string &filePath) const
{
	std::ofstream file(filePath);
	if (!file.is_open())
		throw std::runtime_error("Unable to open file");

	file << "P2\n";
	file << "# Generated by Image class\n";
	file << cols << " " << rows << "\n";
	file << 255 << "\n"; // Maximum pixel value

	for (size_t i = 0; i < rows; ++i)
	{
		for (size_t j = 0; j < cols; ++j)
		{
			file << at(i, j) << " ";
		}
		file << "\n";
	}
}

// Calculate a histogram
std::vector<double> Image::computeHistogram(size_t bins) const
{
	if (bins < 1)
		throw std::invalid_argument("Bins must be greater than zero");

	std::vector<double> histogram(bins, 0.0);
	int maxVal = 255;
	double binSize = static_cast<double>(maxVal + 1) / bins;

	// Counting pixels in each interval
	for (const auto &pixel : pixels)
	{
		size_t binIndex = std::min(static_cast<size_t>(pixel / binSize), bins - 1);
		histogram[binIndex] += 1.0;
	}

	// Normalize
	for (double &value : histogram)
	{
		value /= pixels.size();
	}

	return histogram;
}
